## Описание решения
Далее описаны решения по поводу реализации требований.
### Узлы ShaderLab
Все операции языка ShaderLab можно разделить на следующие типы:
* Постоянные (Константы);
* Логические операторы (If);
* Математические операторы (floor, cos);
* Операции над текстурами;
* Операции над вершинами;
* Преобразования системы координат(TransformWorldToLocal).
* Время 

Каждый тип имеет свой набор операций со своими особенностями. К примеру, константы никогда не будут имеют входные порты на узлах, в то время как текстуры имеют в качестве входного параметра координаты UV. Однако, каждый узел должен иметь одинаковый интерфейс для генерации кода, чтобы упростить задачу обработки графа при создании шейдера.

Особенность языка ShaderLab в том, что он тесно связан с возможностями интерфейса Unity. Многие свойства(Properties) шейдера могут иметь свои аттрибуты, влияющие на диапазон значений или привязывающие это св-во к материалу, делая его не глобальным. Эти параметры необходимо учитывать при создании св-в шейдера, поэтому каждый узел должен иметь определенные поднастройки для аттрибутов. Полный перечень аттрибутов можно посмотреть в документации Unity. [1]

Самый простой(и расширяемый) вариант для системы узлов является дерево. В качестве корня используется класс, содержащий в себе общий для всех интерфейс (логика генерации кода, обработка событий, масштабирование и т.п.). Следующий уровень будет разделение на конкретные типы узлов, в которых лучше всего реализовать создание конкретной формы узла и логику показа предварительной картинки, а дальше уже будет непосредственно классы, реализующие логику узлов и конкретных операций в шейдере. Пример такого дерева представлен на рисунке 1.

Рисунок 1. Пример системы узлов

В рамках языка ShaderLab можно выделить еще один тип операций - операции цикла и массивов. В виду сложности их разработки для визуального программирования(возникает вопрос зацикленности самого графа), данный тип пока не рассматривается в ближайшей разработке. В качестве альтернативы предлагается использования собственного шаблона шейдера, где часть графа будет отдельно записываться в цикл, а результат цикла использоваться далее уже под конкретным именем. 
### Собственные узлы и функции
Используя систему узлов, предложенную выше, можно создавать собственные узлы при помощи расширения дерева узлов. Однако, для людей, не занимающихся программированием, это может быть достаточно тяжело, поэтому предлагается использовать редактор функций. Редактор функций представляет собой такой же редактор для визуального программирования шейдеров, но имеет в себе дополнительные создаваемые узлы - входные и выходные узлы(Input и Output соответственно). Эти узлы будут являться входными и выходными портами создаваемого узла, а в качестве набора операций будет использоваться граф, созданный между этими узлами. 
### Шаблоны шейдера
Вариантов использования шейдеров очень много и создать универсальный шаблон не получится. Из наиболее часто используемых шаблонов можно выделить стандартный для Unity Surface Shader, который указывает материалу данные для физически корректного рендера(Physically based rendering).

В случае если пользователю недостаточно стандартных шейдеров, ему может потребоваться создать свой шаблон и свой список выходных данных. Для этого предлагается написать свой шейдер с определенной разметкой, вместо которой после генерации кода шейдера будет находиться необходимая часть дерева. В качестве примера можно привести следующую строку: **float dist = |"Distance", 2|**. После генерации шейдера будет создана другая строка, которая использует код, созданный из дерева, исходящего от второго параметра под названием Distance в списке выходных данных.
### Предпросмотр
Предпросмотр является одним из наиболее важных требований для динамичных шейдеров, поскольку необходимо постоянно отслеживать динамику формы, цвета или геометрии. В Unity имеется встроенное окно предпросмотра материалов и шейдеров, однако оно имеет достаточно ограниченные возможности, поэтому для редактора реализовано собственное окно предпросмотра, в котором можно загрузить собственную модель, а так же подключить необходимые шейдеры пост-обработки. 

Помимо окна предпросмотра, каждый узел содержит в себе окно, в котором показывается текущее состояние операции. К примеру, если узел работает с текстурой, то показывается видоизмененная текстура прямо на узле. Для этого генерируется шейдер до заданной операции и выводится результат шейдера. Однако, при большом кол-ве операций такой подход может быть не самый производительный, поэтому требуется дополнительное тестирование и оптимизация такого предпросмотра. 
### Интерфейс 
Для сохранения стандартного макета и стиля Unity, окно редактора наследуется от класса EditorWindow. Это позволяет переносить окно редактора, скрывать его среди вкладок уже в существующем макете и использовать его как стандартное окно в Unity. 

Для реализации стандартных действий, вроде Копировать, Вставить, Назад, Вперед и сохранения логов действий пользователя используется шаблон проектирования Команда. [2] Все действия на сцене вызываются через единый интерфейс Action, что позволяет возвращать редактор к состоянию предыдущих действий, а так же позволяет отслеживать и логировать историю действий пользователя в случае ошибки.
### Генерация кода 
Генерация кода шейдера происходит рекурсивно, выполняясь с конца(проходя по списку выходных параметров). Основными принципами при генерации кода является использование наименьшего кол-ва временных переменных, поскольку они способны сильно затруднить чтение кода, и использование понятных названий таких переменных. 

Пользователь так же может лично отслеживать удоство чтения кода при помощи определенных узлов - создание переменной и чтение переменной. Организуя граф на функциональные участки с конкретными результатами пользователь способен получить более понятный код, чем без использования переменных. 
