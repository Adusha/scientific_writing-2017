
## Выбор метода решения

На основе сравнения аналогов, а также согласно выявленным требованиям заказчиков, решение должно обладать следующими качествами:

+ Настраиваемость. Настройки системы должны быть вынесены на административный интерфейс таким образом, чтобы для вступления изменений в силу не требовался перезапуск приложения. 
+ Простая интеграция с внешними системами. Использованеие WSDL (Web Service Definition Language) и JSON API обычно связано с кодогенерацией, а также с внесением изменений в текущую кодовую базу. Требуется создать интерфейс для генерации RPC-методов на основе загруженных пользователем WSDL или JSON-файлов.  
+ Кластерность. Система должна поддерживать возможность быть запущенной в кластере, т.е. на нескольких серверах одновременно. Для этого необходимо использовать СУБД, поддерживающие master-slave репликацию, а также распределённые коллекции (например, in memory data grid Hazelcast).
+ Отказоустойчивость. Необходимо обеспечить отказоустойчивость системы, с помощью инструментов мониторинга. Приложениие должно иметь возможность быть восстановленным после ошибки. Для этого можно использовать Zabbix, который обладает функционалом проверки статуса приложения и запуском скриптов (например, скриптов для перезапуска приложения) при изменении статуса.
+ Простота развёртывания. Для упрощения развёртывания приложения можно поставлять заказчику docker образ (а также утилиту docker-compose, для создания сети и кластера). Во-первых это упростит (и ускорит) перезапуск приложения после критической ошибки, а во-вторых позволит каждому экземпляру приложения иметь одинаковую среду запуска.
+ Тестируемость. Приложение должно быть легко тестируемым. Так как для разработки был выбран фреймворк Spring, в котором используется паттерн dependency injection, для тестирования используются библиотеки Spring Test, Mockito и JUnit. Они позволяют тестировать отдельные компоненты приложения, заменяя другие заглушками. Также, с помощью Spring Test можно проводить интеграционное тестирование всего приложения целиком. Процесс тестирования запускается после каждого push'a в Gitlab-репозиторий с помощью Gitlab CI. Для тестирования был создан специальный docker-контейнер, использование которого позволяет тестировать как отдельные экземпляры приложения, так и кластер их нескольких экземпляров.

Для реализации алгоритмов машинного обучения были выбраны фреймворки Scikit и Apache Lucene. Scikit является самым популярным инструментов в data science, так как предоставляет удобное API, а также о его использовании написано большое количество материалов. Scikit содержит основные алгоритмы машинного обучения такие как логрегрессия, kNN, random decision tree, gradient descent. Также в нём содержаться методы оценки моделей. Apache Lucene используется для обработки текста: например, для создания индекса из ngram и последующего полнотекстового поиска. Оба фреймворка обладают функционалом online-обучения (т.е. модели можно улучшать на основе новых данных, которые добавляют пользователи приложения).




### Ranking
X — множество объектов  
Xℓ = {x1, . . . , xℓ} — обучающая выборка  
i ≺ j — правильный порядок на парах (i, j) ∈ {1, . . . , ℓ}2  
Задача:  
построить ранжирующую функцию a : X → R такую, что  
i ≺ j ⇒ a(xi) < a(xj)  
Линейная модель ранжирования:  
a(x;w) = x,w  
где x 7→ f1(x), . . . , fn(x) ∈ Rn — вектор признаков объекта x  

D — коллекция текстовых документов (documents)  
Q — множество запросов (queries)  
Dq ⊆ D — множество документов, найденных по запросу q  
X = Q × D — объектами являются пары «запрос, документ»:  
x ≡ (q, d), q ∈ Q, d ∈ Dq  
Y — упорядоченное множество рейтингов  
y : X → Y — оценки релевантности, поставленные асессорами:  
чем выше оценка y(q, d), тем релевантнее документ d запросу q  
Правильный порядок определён только между документами,  
найденными по одному и тому же запросу q:  
(q, d) ≺ (q, d) ⇔ y(q, d) < y(q, d)  

### Feature Extraction (Выявление признаков)

TF-IDF
TF-IDF(q, d) — мера релевантности документа d запросу q

Word2Vec
Векторное представление фразы

### Model Evaluation

