
## Описание решения

### Технологии
Для кластеризации решения используется СУБД Postgre, поддерживающая master-slave репликацию, а также in memory data grid Hazelcast, дающая возможность использовать распределённые коллекции.  
Для упрощения развёртывания приложения был создан docker образ. Это упрощает и ускоряет перезапуск приложения после критической ошибки, а также позволяет каждому экземпляру приложения иметь одинаковую среду запуска.  
Для разработки основной части приложения используется фреймворк Spring. Для тестирования используются библиотеки Spring Test, Mockito и JUnit. Они позволяют тестировать отдельные компоненты приложения, заменяя другие заглушками. Также, с помощью Spring Test можно проводить интеграционное тестирование всего приложения целиком. Процесс тестирования запускается после каждого push'a в Gitlab-репозиторий с помощью Gitlab CI. Для тестирования был создан специальный docker-контейнер, использование которого позволяет тестировать как отдельные экземпляры приложения, так и кластер из нескольких экземпляров.  

Для реализации алгоритмов машинного обучения были выбраны фреймворки Scikit и Apache Lucene. Scikit является самым популярным инструментов в data science, так как предоставляет удобное API, а также о его использовании написано большое количество материалов. Scikit содержит основные алгоритмы машинного обучения такие как логрегрессия, kNN, random decision tree, gradient descent. Также в нём содержаться методы оценки моделей. Apache Lucene используется для обработки текста: например, для создания индекса из ngram и последующего полнотекстового поиска. Оба фреймворка обладают функционалом online-обучения (т.е. модели можно улучшать на основе новых данных, которые добавляют пользователи приложения).

### Алгоритм ранжирования
X — множество объектов  
Xℓ = {x1, . . . , xℓ} — обучающая выборка  
i ≺ j — правильный порядок на парах (i, j) ∈ {1, . . . , ℓ}2  
Задача:  
построить ранжирующую функцию a : X → R такую, что  
i ≺ j ⇒ a(xi) < a(xj)  
Линейная модель ранжирования:  
a(x;w) = x,w  
где x 7→ f1(x), . . . , fn(x) ∈ Rn — вектор признаков объекта x  

D — коллекция текстовых документов (documents)  
Q — множество запросов (queries)  
Dq ⊆ D — множество документов, найденных по запросу q  
X = Q × D — объектами являются пары «запрос, документ»:  
x ≡ (q, d), q ∈ Q, d ∈ Dq  
Y — упорядоченное множество рейтингов  

### Feature Extraction (Выявление признаков)

#### TF-IDF
TF-IDF(q, d) — мера релевантности документа d запросу q  
Мера TF-IDF часто используется для представления документов коллекции в виде числовых векторов, отражающих важность использования каждого слова из некоторого набора слов (количество слов набора определяет размерность вектора) в каждом документе. Подобная модель называется векторной моделью и даёт возможность сравнивать тексты, сравнивая представляющие их вектора в какой-либо метрике (евклидово расстояние, косинусная мера, манхэттенское расстояние, расстояние Чебышёва и др.), то есть производя кластерный анализ. Мера TF-IDF используется как один из признаков для ранжирования.

#### Word2Vec
Векторное представление слов. Представления векторов-слов позволяют вычислять семантическое расстояние между словами. Семаническое расстояние одного документа от другого будет использоваться как один из признаков для ранжирования.

### Оценка модели
Для оценки модели используется заранее подготовленный набор данных. Порядок ответов для данного набора (образец) определён людьми-аннотаторами. Показателем качества модели будет разница между выдачей модели и образцом.
